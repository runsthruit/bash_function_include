#! /bin/bash

function bash_function_init ()
#
#
#
{

	declare __bash_function_init_{mods,opts,{locv,glbv}_{strings,arrays}}=
	__bash_function_init_mods=()
	__bash_function_init_opts=(
		init
	)
	__bash_function_init_locv_strings=()
	__bash_function_init_locv_arrays=()
	__bash_function_init_glbv_strings=(
		INIT_SRC
	)
	__bash_function_init_glbv_arrays=()

	declare INIT_SRC=
	declare INIT_RGX=".*[^[:blank:]]([[:blank:]]*### BASH_FUNCTION_INIT INIT ###.*### BASH_FUNCTION_INIT INIT ###).*"
	[[ "$( < "${BASH_SOURCE[0]}" )" =~ ${INIT_RGX} ]] \
	&& INIT_SRC="${BASH_REMATCH[1]}" \
	|| INIT_SRC="echo \"${FUNCNAME[0]}: FAIL\" 1>&2; return 1"

	eval "${INIT_SRC}"

	[ "${OPT_help}" -eq 0 ] \
	|| {
		cat - 1>&2 <<-EOF

		DESCRIPTION::
		
		  Initializes a function with some sanity.
		  Properly globalizes & localizes variables.
		  Does basic command-line option parsing.

		USAGE::

		  To initialize your function,
		  insert the following line at the beginning of your function..

		EOF
		echo "$( eval "${INIT_SRC}" 2>&1 )" | sed "1d;s/^/    /"
		cat - 1>&2 <<-EOF
		    : ${TAG%%/*} INIT; eval "\$( ${FNC} --init || echo return 1 )"

		  If you want to be able to run the function as a script,
		  or warn users that it is not to be run as a script,
		  add the following to the end of your function source,
		  *OUTSIDE* of the function.

		    : ${TAG%%/*} RUN; I="\${BASH_SOURCE[0]##*/}"; [ "\${I}" != "\${0}" -a "\${#BASH_SOURCE[@]}" -ne 0 ] || \${I%.*} \${@:+"\${@}"}

		WARNING::

		  Assumes your function is *EQUAL* to the name of your script,
		  minus an extension. ( ie. ".bash", ".bash_function", etc. )

		EOF
		return 1
	}

	echo "${INIT_SRC}"

	return 0

	### BASH_FUNCTION_INIT INIT ###

	#
	for __bash_function_init_ent in __bash_function_init_{mods,opts,{locv,glbv}_{strings,arrays}}
	do
		eval "declare -p ${__bash_function_init_ent}" &>/dev/null \
		|| {
			printf "# Set the following in your function, before the call to BASH_FUNCTION_INIT..\n"
			printf "declare %s=\n" "__bash_function_init_{mods,opts,{locv,glbv}_{strings,arrays}}"
			printf "%s=()\n" __bash_function_init_{mods,opts,{locv,glbv}_{strings,arrays}}
			printf "\n"
			return 1
		} 1>&2
	done

	#
	__bash_function_init_fnc="${FUNCNAME[0]:-}"
	__bash_function_init_tag="$( echo "${__bash_function_init_fnc}" | tr "[:lower:]" "[:upper:]" )"

	#
	__bash_function_init_mods=(
		${__bash_function_init_mods:+"${__bash_function_init_mods[@]}"}
	)
	__bash_function_init_opts=(
		bash_function_init
		help
		debug
		${__bash_function_init_opts:+"${__bash_function_init_opts[@]}"}
	)
	__bash_function_init_locv_strings=(
		FNC TAG TMP ENT VAR VAL I J K RGX DBG
		TAB NLN CRT
		FLG_sourced
		${__bash_function_init_locv_strings:+"${__bash_function_init_locv_strings[@]}"}
	)
	__bash_function_init_locv_arrays=(
		LOCV
		GLBV
		ARGS
		${__bash_function_init_locv_arrays:+"${__bash_function_init_locv_arrays[@]}"}
	)
	__bash_function_init_glbv_strings=(
		DEBUG_${__bash_function_init_tag}
		${__bash_function_init_glbv_strings:+"${__bash_function_init_glbv_strings[@]}"}
	)
	__bash_function_init_glbv_arrays=(
		${__bash_function_init_glbv_arrays:+"${__bash_function_init_glbv_arrays[@]}"}
	)

	#
	for __bash_function_init_var in ${__bash_function_init_locv_strings[*]:-}
	do
		eval "declare ${__bash_function_init_var}="
	done
	for __bash_function_init_var in ${__bash_function_init_locv_arrays[*]:-}
	do
		eval "declare ${__bash_function_init_var}=()"
	done
	for __bash_function_init_var in ${__bash_function_init_glbv_strings[*]:-} ${__bash_function_init_glbv_arrays[*]:-}
	do
		eval "export ${__bash_function_init_var}"
	done
	for __bash_function_init_var in ${__bash_function_init_glbv_strings[*]:-}
	do
		eval "${__bash_function_init_var}=\${${__bash_function_init_var}:-}"
	done
	for __bash_function_init_var in ${__bash_function_init_glbv_arrays[*]:-}
	do
		eval "${__bash_function_init_var}=( \${${__bash_function_init_var}[@]:+\"\${${__bash_function_init_var}[@]}\"} )"
	done

	#
	eval "printf -v TAB \"\t\""
	eval "printf -v NLN \"\n\""
	eval "printf -v CRT \"\r\""
	eval "FNC=\"\${__bash_function_init_fnc}\""
	eval "TAG=\"\${__bash_function_init_tag}/\${RANDOM}/\${SECONDS}\""
	eval "DBG=\"\${DEBUG_${__bash_function_init_tag%%/*}:-0}\""
	[ "${BASH_SOURCE[0]}" == "${0}" -o "${#BASH_SOURCE[@]}" -eq 0 ] && FLG_sourced=0 || FLG_sourced=1

	#
	for __bash_function_init_ent in ${__bash_function_init_opts[*]%%=*}
	do
		eval "declare OPT_${__bash_function_init_ent}=0"
	done
	__bash_function_init_rgx_opts="${__bash_function_init_opts[*]%%=*}"
	__bash_function_init_rgx_opts="--${__bash_function_init_rgx_opts// /|--}"
	__bash_function_init_rgx_skip=0
	for __bash_function_init_ent in ${@:+"${@}"}
	do
		[[ "${__bash_function_init_rgx_skip}" == "0" && "${__bash_function_init_ent}" =~ (-h|-help|--|${__bash_function_init_rgx_opts})(=.+)* ]] \
		&& {
			__bash_function_init_var="${BASH_REMATCH[1]}"
			__bash_function_init_val="${BASH_REMATCH[2]}"
			case "${__bash_function_init_var}" in
			( -h | -help | --help ) {
				OPT_help=1
				break
			};;
			( --* ) {
				[ "${__bash_function_init_var}" != "--" ] \
				|| { __bash_function_init_rgx_skip=1; continue; }
				[[ "${__bash_function_init_val}" =~ ^= ]] \
				&& {
					eval "OPT_${__bash_function_init_var#--}=\"${__bash_function_init_val#=}\""
				} \
				|| {
					eval "OPT_${__bash_function_init_var#--}=\$((\${OPT_${__bash_function_init_var#--}:-0}+1))"
				}
			};;
			esac
		} \
		|| ARGS[${#ARGS[@]}]="${__bash_function_init_ent}"
	done

	#
	[ "${OPT_debug}" -eq 0 ] || DBG="${OPT_debug}"
	LOCV=( ${__bash_function_init_opts[*]/#/OPT_} ${__bash_function_init_locv_strings[*]:-} ${__bash_function_init_locv_arrays[*]:-} )
	GLBV=( ${__bash_function_init_glbv_strings[*]:-} ${__bash_function_init_glbv_arrays[*]:-} )

	#
	for __bash_function_init_ent in ${__bash_function_init_mods[@]:+"${__bash_function_init_mods[@]}"}
	do
		echo "::: ${__bash_function_init_ent}" 1>&2
	done

	#
	unset ${!__bash_function_init*}

	### BASH_FUNCTION_INIT INIT ###

}

: BASH_FUNCTION_INIT RUN; I="${BASH_SOURCE[0]##*/}"; [ "${I}" != "${0}" -a "${#BASH_SOURCE[@]}" -ne 0 ] || ${I%.*} ${@:+"${@}"}
